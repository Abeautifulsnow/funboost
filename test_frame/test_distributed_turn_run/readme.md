
## 用户的需求是:

每台机器轮流执行一个消息,只有当上一台机器运行完成消息后,下一台机器才开始运行下一条消息.

如果用redis分布式锁只能保证多台机器只有一个线程运行某个代码块,从而确保多台机器只有一个在运行,但没法保证是每台机器轮流执行消息.

```
用户有机器1  机器2  机器3  .... 机器10
用户希望每台机器轮流从 queue1 队列获取消息,并运行,
就是 机器1 获取 msg1 后并运行完成,  机器2 才开始获取msg2并运行完成, 然后机器3开始获取msg3并运行完成, .......,周而复始.

```

用户的实际例子需求是 ,利用非常多台物理机ip反爬虫

```
该用户不使用ip代理池,而是利用多台物理机的真实ip反爬虫,用户希望轮流在多台机器请求url,
同时保证多台机器只有一个机器在单并发的运行爬取url,避免触发ip反爬虫,
用户不希望所谓的使用ssh链接到远程机器 来curl爬虫,也不希望使用物理机搭建ip代理服务,就是正常的多台机器上部署相同所谓python爬虫代码.
```

## 使用单个机器模拟实现用户的如下奇葩特殊需求


```
现在是在单台机器分两个脚本启动消费,模拟实现  "两个机器轮流运行消息,并且同时只有一台机器在执行消息,同时只有一个消息被执行,不允许并发运行消息 " 这个需求.

实际上是动态自动获取当前机器ip,不需要 run_execute_msg_on_host101.py run_execute_msg_on_host102.py 两个重复的文件

```



## 难点和解决方式
```
难点:
要实现多台物理机只有一台在进行爬取url,这个使用redis 分布式锁就可以保证了.

解决方式:
要保证每台机器轮流爬一个url,那就不光是分布式锁就能解决了
所以使用单线程并发模式 + 分发到不同的ip队列,使用rpc阻塞等待可以确保爬虫函数执行完成,从而再分发下一条消息,
这样就能达到多台机器只有一个机器在运行,并保证每台机器轮流爬虫.

具体到funboost就是:
写一个消息分发函数,该函数必须使用单线程并发模式,这个函数里面使用rpc 阻塞等待获取 消息执行函数的结果,
再写一个正正的具体执行消息的函数,该函数必须设置支持rpc模式,is_using_rpc_mode=True,
```

## 如果是scrapy和仿scrapy api用法的框架,非常难实现

```
如果是scrapy和仿scrapy api用法的框架,非常难实现,
因为你完全不知道需要改框架哪里,这种奇葩需求也不好搜答案.

funboost框架是函数调度框架,部署url调度框架,所以自由灵活,用户任何奇葩独特想法不需要涉及到需要改funboost框架
```


## 脚本说明
```
run_distribute_msg.py 是 从queue1 获取消息,并轮流分发到 queue2的各个ip对应的队列名字,
distribute_msg函数是单线程并发模式,并且采用了rpc模式阻塞等待函数运行完成,才会继续分发消息到下一台机器的队列中,
从而保证了每台机器轮流运行一条消息(每台机器轮流获取一个url种子并爬取)

run_execute_msg_on_host101.py 和 run_execute_msg_on_host102.py 是为了方便单台机器模拟在两台机器上运行,
实际不需要重复的写这两个文件.
```